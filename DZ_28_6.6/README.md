# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

<u>Ответ:</u>

1. Необходимо определить выполнение операций свыше 3-х минут в БД (напр.DB):

   ```
   db.currentOp(
      {
        "active" : true,
        "secs_running" : { "$gt" : 180 },
        "ns" : /^BD\./
      }
   )
   ```

2. Устраняем операцию по id:

   ```
   db.killOp(<opid of the query to kill>)
   ```

​			

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

​			<u>Ответ:</u>  

Необходимо внимательно рассмотреть причины вызывающая зависание запросов, можно выполнить explain.

Можно ограничить время выполнения в коде: db.collection_name.find(<query_string>).maxTimeMS(<time_limit>)

Возможно необходимо масштабировать БД, построить соответствующие индексы.



## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

​		<u>Ответ:</u>  

Данная проблема связана с увеличением числа истекших записей. Цикл активного механизма Redis удаления ключей запускается каждые 100 миллисекунд (10 раз в секунду) и по умолчанию процесс выполняется десять раз в секунду, 200 ключей в секунду (ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP по умолчанию установлено значение 20). Если обнаруживается, что количество истекших записей более 25%, механизм зацикливается и блокирует до того момента, пока количество не станет меньше 25%.  

## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

<u>Ответ:</u>  

Возможна проблема с таймаутом при ожидании ответа на запрос. Таймаут задается в параметре net_read_timeout и по умолчанию составляет 30 секунд.  Увеличить значение net_read_timeout.

Возможна проблема со значениями BLOB-объектов, которые больше, чем max_allowed_packet, что может вызвать эту ошибку у некоторых клиентов. Тогда это зачастую сопровождается ошибкой ER_NET_PACKET_TOO_LARGE. В данном случае нужно увеличить значение max_allowed_packet.



## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

<u>Ответ:</u>  

Данная проблема связана с тем, что PostgreSQL становится при исчерпании памяти и ресурсов. Если в системе мало памяти и освободить ее невозможно, вызывается функция out_of_memory, далее возникает процесс Out-Of-Memory Killer, который завершает процесс postmaster. Таким образом, принудительно завершается процесс PostgreSQL.

Как бы вы решили данную проблему?

<u>Ответ:</u>  

Необходимо провести конфигурирование и настройку работы PostgreSQL с памятью. Конфигурация связанная с памятью, в частности снижением shared_buffers и work_mem.
shared_buffers (integer)
Задаёт объём памяти, который будет использовать сервер баз данных для буферов в разделяемой памяти. По умолчанию это обычно 128 мегабайт (128MB). Это значение не должно быть меньше 128 килобайт. Однако для хорошей производительности обычно требуются гораздо большие значения. Разумным начальным значением shared_buffers будет 25% от объёма памяти. Существуют варианты нагрузки, при которых эффективны будут и ещё большие значения shared_buffers, но так как PostgreSQL использует и кеш операционной системы, выделять для shared_buffers более 40% ОЗУ не будет полезно. 

work_mem (integer). Данный параметр Задаёт базовый максимальный объём памяти, который будет использоваться во внутренних операциях при обработке запросов (например, для сортировки или хеш-таблиц), прежде чем будут задействованы временные файлы на диске. Значение по умолчанию — четыре мегабайта (4MB). Необходимо учесть, что в сложных запросах параллельно могут выполняться несколько операций сортировки или хеширования, и при этом примерно этот объём памяти может использоваться в каждой операции, прежде чем данные начнут вытесняться во временные файлы. Кроме того, такие операции могут выполняться одновременно в разных сеансах. Таким образом, общий объём памяти может многократно превосходить значение work_mem, что в свою очередь может вызвать Out-Of-Memory Killer. Также необходимо учитывать что сильно занижать данный параметр не стоит. 

